<script>
  const map = L.map('map').setView([0, 0], 13);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; OpenStreetMap contributors',
    opacity: 0.4
  }).addTo(map);

  // Paleta Viridis (10 tonos)
  const viridis = [
    '#440154', '#482777', '#3E4989', '#31688E',
    '#26828E', '#1F9E89', '#35B779', '#6CCE59',
    '#B4DE2C', '#FDE725'
  ];

  // Devuelve un color interpolado de la paleta Viridis
  function getColorFromElevation(elev, minElev, maxElev) {
    const ratio = (elev - minElev) / (maxElev - minElev);
    const index = Math.max(0, Math.min(viridis.length - 1, Math.floor(ratio * (viridis.length - 1))));
    return viridis[index];
  }

  document.getElementById('gpxfile').addEventListener('change', function (e) {
    const file = e.target.files[0];
    const reader = new FileReader();

    reader.onload = function () {
      const parser = new DOMParser();
      const xml = parser.parseFromString(reader.result, 'text/xml');
      const geojson = toGeoJSON.gpx(xml);

      const latlngs = [];
      const elevations = [];
      const distances = [0];
      let totalDistance = 0;
      let gain = 0, loss = 0;

      const coords = geojson.features[0].geometry.coordinates;
      for (let i = 0; i < coords.length; i++) {
        const [lon, lat, ele] = coords[i];
        latlngs.push([lat, lon]);
        elevations.push(ele);

        if (i > 0) {
          const prev = L.latLng(latlngs[i - 1]);
          const curr = L.latLng(latlngs[i]);
          const segmentDistance = prev.distanceTo(curr);
          totalDistance += segmentDistance;
          distances.push(distances[distances.length - 1] + segmentDistance / 1000);

          const deltaElev = ele - elevations[i - 1];
          if (deltaElev > 0) gain += deltaElev;
          else loss -= deltaElev;
        }
      }

      // Elevation stats
      const minElev = Math.min(...elevations);
      const maxElev = Math.max(...elevations);

      // Dibujar segmentos con color por elevación
      for (let i = 1; i < latlngs.length; i++) {
        const avgElev = (elevations[i] + elevations[i - 1]) / 2;
        const color = getColorFromElevation(avgElev, minElev, maxElev);
        L.polyline([latlngs[i - 1], latlngs[i]], { color, weight: 4 }).addTo(map);
      }

      map.fitBounds(L.polyline(latlngs).getBounds());

      // Gráfico de elevación
      const ctx = document.getElementById('elevationChart').getContext('2d');
      new Chart(ctx, {
        type: 'line',
        data: {
          labels: distances,
          datasets: [{
            label: 'Elevation (m)',
            data: elevations,
            borderColor: 'green',
            fill: true,
            backgroundColor: 'rgba(0, 128, 0, 0.1)',
            tension: 0.1
          }]
        },
        options: {
          scales: {
            x: { title: { display: true, text: 'Distance (km)' } },
            y: { title: { display: true, text: 'Elevation (m)' } }
          },
          plugins: {
            legend: { display: false },
            tooltip: { mode: 'index', intersect: false }
          }
        }
      });

      document.getElementById('stats').innerHTML = `
        <strong>Total Distance:</strong> ${(totalDistance / 1000).toFixed(2)} km<br>
        <strong>Elevation Gain:</strong> ${gain.toFixed(1)} m<br>
        <strong>Elevation Loss:</strong> ${loss.toFixed(1)} m<br>
        <strong>Minimum Elevation:</strong> ${minElev.toFixed(1)} m<br>
        <strong>Maximum Elevation:</strong> ${maxElev.toFixed(1)} m<br>
      `;
    };

    reader.readAsText(file);
  });
</script>
